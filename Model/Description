
Firstly, our method is to solve the problem of sequential recommendation in multi-behavior scenarios, which belongs to the 
category of sequential learning/decision. 

One crucial technique is the Fast Fourier Transform, which is essential in the digital signal processing area. 
Therefore, the application scope of our method belongs to the category of signal processing methods. 

Secondly, our method focuses on exploring the sequential patterns behind user-item interactions when incorporating the 
multi-behavior dependencies for accurate recommendation, which is easy to tell because of the clear model architecture. 



About the "Hypergraph Architecture", we use item tritision hypergraph and multi-behavior hypergraph.

Code:

def build_Gs_unique(self, seqs, type_seqs):
    Gs = []
    n_objs = torch.count_nonzero(seqs, dim=1).tolist()
    for batch_idx in range(seqs.shape[0]):
        seq = seqs[batch_idx]
        n_obj = n_objs[batch_idx]
        seq = seq[:n_obj].cpu()
        seq_list = seq.tolist()
        unique_tensor = torch.unique(seq)
        unique = unique_tensor.tolist()
        n_unique = len(unique)

        # 行为ID
        type_seq = type_seqs[batch_idx]
        type_seq = type_seq[:n_obj].cpu()
        type_seq_list = type_seq.tolist()
        type_unique_tensor = torch.unique(type_seq)
        type_unique = type_unique_tensor.tolist()
        n_type_unique = len(type_unique)

        multibeh_group = seq.tolist()
        for x in unique:
            multibeh_group.remove(x)
        multibeh_group = list(set(multibeh_group))
        try:
            multibeh_group.remove(self.mask_token)
        except:
            pass


        multibeh_group = seq.tolist()
        for x in unique:
            multibeh_group.remove(x)
        multibeh_group = list(set(multibeh_group))
        try:
            multibeh_group.remove(self.mask_token)
        except:
            pass

        n_edge = n_unique + len(multibeh_group)
        H = torch.zeros((n_obj, n_edge)).to(device)

        edge_idx = 0
        # generate in-item hyperedge, ignore 0
        for item in unique:
            if item != 0:
                for i in range(1, len(seq_list)):
                    if seq_list[i] == item:
                        prev_item_idx = unique.index(seq_list[i - 1])
                        H[prev_item_idx, edge_idx] = 1.0
                curr_item_idx = unique.index(item)
                H[curr_item_idx, edge_idx] += 1.0
                edge_idx += 1
   

        for i, item in enumerate(seq_list):
            ego_idx = unique.index(item)
            H[i, ego_idx] = 1.0
            # multi-behavior hyperedge
            if item in multibeh_group:
                H[i, n_unique + multibeh_group.index(item)] = 1.0

        DV = torch.sum(H, dim=1)
        DE = torch.sum(H, dim=0)
        invDE = torch.diag(torch.pow(DE, -1))
        invDV = torch.diag(torch.pow(DV, -1))
        # DV2 = torch.diag(torch.pow(DV, -0.5))
        HT = H.t()
        G = invDV.mm(H).mm(invDE).mm(HT)
        # G = DV2.mm(H).mm(invDE).mm(HT).mm(DV2)
        assert not torch.isnan(G).any()
        Gs.append(G.to(seqs.device))
    Gs_block_diag = torch.block_diag(*Gs)

    return Gs_block_diag
